{"version":3,"sources":["../src/index.js"],"names":["const","fetchF","Future","input","options","reject","resolve","response","let","header","keys","all","headers","request","getAllResponseHeaders","replace","m","key","value","push","toLowerCase","ok","status","statusText","url","responseURL","clone","text","of","responseText","json","JSON","parse","xml","responseXML","blob","Blob","entries","get","n","has","XMLHttpRequest","open","method","i","setRequestHeader","withCredentials","credentials","onload","onerror","send","body"],"mappings":"sDAAOA,IAAMC,GAAS,SAAAC,GAAO,MAAG,UAAUC,EAAOC,GAC/C,0BAAO,GAAIF,GAAO,SAACG,EAAQC,GACzB,YAcA,SAASC,KACPC,GAGIC,GAHAC,KACAC,KACAC,IASJ,OANAC,GAAQC,wBAAwBC,QAAQ,0BAA2B,SAACC,EAAGC,EAAKC,GAC1ER,EAAKS,KAAKF,EAAMA,EAAIG,eACpBT,EAAIQ,MAAMF,EAAKC,IACfT,EAASG,EAAQK,GACjBL,EAAQK,GAAOR,EAASA,EAAS,IAAIS,EAAUA,KAG/CG,GAAmC,IAA9BR,EAAQS,OAAS,IAAM,GAC5BA,OAAQT,EAAQS,OAChBC,WAAYV,EAAQU,WACpBC,IAAKX,EAAQY,YACbC,MAAOnB,EACPoB,KAAM,WAAG,MAAGzB,GAAO0B,GAAGf,EAAQgB,eAC9BC,KAAM,WAAG,MAAG5B,GAAO0B,GAAGG,KAAKC,MAAMnB,EAAQgB,gBACzCI,IAAK,WAAG,MAAG/B,GAAO0B,GAAGf,EAAQqB,cAC7BC,KAAM,WAAG,MAAGjC,GAAO0B,GAAG,GAAIQ,OAAMvB,EAAQN,aACxCK,SACEF,KAAM,WAAG,MAAGA,IACZ2B,QAAS,WAAG,MAAG1B,IACf2B,IAAK,SAAAC,GAAE,MAAG3B,GAAQ2B,EAAEnB,gBACpBoB,IAAK,SAAAD,GAAE,MAAGA,GAAEnB,eAAiBR,MAvCnCJ,GAAIK,GAAU,GAAI4B,gBACdjB,EAAMrB,CACVU,GAAQ6B,KAAKtC,EAAQuC,QAAU,MAAOnB,EAEtC,KAAKhB,GAAIoC,KAAKxC,GAAQQ,QACpBC,EAAQgC,iBAAiBD,EAAGxC,EAAQQ,QAAQgC,GAG9C/B,GAAQiC,gBAA0C,YAAxB1C,EAAQ2C,YAClClC,EAAQmC,OAAS,WAAG,MAAG1C,GAAQC,MAC/BM,EAAQoC,QAAU5C,EAClBQ,EAAQqC,KAAK9C,EAAQ+C","file":"fetch-future.js","sourcesContent":["export const fetchF = Future => function (input, options = {}) {\n  return new Future((reject, resolve) => {\n    'use strict'\n    let request = new XMLHttpRequest()\n    let url = input;\n    request.open(options.method || 'get', url)\n\n    for (let i in options.headers) {\n      request.setRequestHeader(i, options.headers[i])\n    }\n\n    request.withCredentials = options.credentials === 'include'\n    request.onload = () => resolve(response())\n    request.onerror = reject\n    request.send(options.body)\n\n    function response () {\n      let keys = []\n      let all = []\n      let headers = {}\n      let header\n\n      request.getAllResponseHeaders().replace(/^(.*?):\\s*([\\s\\S]*?)$/gm, (m, key, value) => {\n        keys.push(key = key.toLowerCase())\n        all.push([key, value])\n        header = headers[key]\n        headers[key] = header ? `${header},${value}` : value\n      })\n      return {\n        ok: (request.status / 200 | 0) === 1,    // 200-399\n        status: request.status,\n        statusText: request.statusText,\n        url: request.responseURL,\n        clone: response,\n        text: () => Future.of(request.responseText),\n        json: () => Future.of(JSON.parse(request.responseText)),\n        xml: () => Future.of(request.responseXML),\n        blob: () => Future.of(new Blob([request.response])),\n        headers: {\n          keys: () => keys,\n          entries: () => all,\n          get: n => headers[n.toLowerCase()],\n          has: n => n.toLowerCase() in headers\n        }\n      }\n    }\n  })\n}\n"]}